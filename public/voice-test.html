<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Praxis Live Voice Test</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 20px; max-width: 700px; margin: auto; }
    button { padding: 10px 14px; margin-right: 8px; }
    #log { white-space: pre-wrap; background: #111; color: #0f0; padding: 12px; height: 260px; overflow: auto; border-radius: 8px; }
    input { padding: 8px; }
  </style>
</head>
<body>
  <h2>Praxis Voice Test (Gemini Live via Cloud Run voice service)</h2>

  <label>Student Email:</label>
  <input id="email" placeholder="student@email.com" style="width: 60%;" />
  <br/><br/>

  <button id="startBtn">Start Voice</button>
  <button id="stopBtn" disabled>Stop</button>

  <h3>Transcript / Events</h3>
  <div id="log"></div>

<script>
  // âœ… Put ONLY your NEW voice service domain here (no https://)
  const CLOUD_RUN_DOMAIN = "your-voice-service-xxxxx-uc.a.run.app";
  const CLOUD_RUN_WS = `wss://${CLOUD_RUN_DOMAIN}/ws/voice`;

  const logEl = document.getElementById("log");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const emailEl = document.getElementById("email");

  let ws, micStream, audioCtx, processor;

  // For playback
  let playCtx = new (window.AudioContext || window.webkitAudioContext)();
  let playQueueTime = 0;

  function log(s) {
    logEl.textContent += s + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  // Float32 [-1..1] -> Int16 PCM
  function floatTo16BitPCM(float32) {
    const out = new Int16Array(float32.length);
    for (let i = 0; i < float32.length; i++) {
      let v = Math.max(-1, Math.min(1, float32[i]));
      out[i] = v < 0 ? v * 0x8000 : v * 0x7FFF;
    }
    return out;
  }

  // Quick linear downsampler to 16kHz
  function downsampleBuffer(buffer, sampleRate, outRate = 16000) {
    if (outRate === sampleRate) return buffer;
    const ratio = sampleRate / outRate;
    const newLen = Math.round(buffer.length / ratio);
    const result = new Float32Array(newLen);

    let offsetResult = 0;
    let offsetBuffer = 0;

    while (offsetResult < result.length) {
      const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);

      let accum = 0, count = 0;
      for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
        accum += buffer[i];
        count++;
      }
      result[offsetResult] = accum / count;

      offsetResult++;
      offsetBuffer = nextOffsetBuffer;
    }
    return result;
  }

  function base64FromInt16(int16) {
    const bytes = new Uint8Array(int16.buffer);
    let bin = "";
    for (let i = 0; i < bytes.byteLength; i++) bin += String.fromCharCode(bytes[i]);
    return btoa(bin);
  }

  function int16FromBase64(b64) {
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return new Int16Array(bytes.buffer);
  }

  async function startVoice() {
    const student_email = emailEl.value.trim();
    if (!student_email) {
      alert("Enter student email");
      return;
    }

    ws = new WebSocket(CLOUD_RUN_WS);

    ws.onopen = () => {
      log("WS opened to backend");
      ws.send(JSON.stringify({
        type: "start",
        sessionId: "voice-" + Date.now(),
        student_email
        // lmsKey: "YOUR_LMS_API_KEY"  // only if you enabled WS auth
      }));
    };

    ws.onmessage = (ev) => {
      const msg = JSON.parse(ev.data);

      if (msg.type === "ready") log("âœ… Gemini Live ready");
      if (msg.type === "text") log("AI: " + msg.text);
      if (msg.type === "audio") playAudioChunk(msg.data);
      if (msg.type === "turnComplete") log("[turn complete]");
      if (msg.type === "error") log("âŒ ERROR: " + msg.error);
      if (msg.type === "closed") log("WS closed by server");
    };

    ws.onclose = (e) => log("WS closed: " + e.code);

    // Mic capture
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioCtx.createMediaStreamSource(micStream);

    // ScriptProcessorNode is deprecated but simplest for a test page
    processor = audioCtx.createScriptProcessor(4096, 1, 1);
    source.connect(processor);
    processor.connect(audioCtx.destination);

    processor.onaudioprocess = (e) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      const input = e.inputBuffer.getChannelData(0);
      const down = downsampleBuffer(input, audioCtx.sampleRate, 16000);
      const pcm16 = floatTo16BitPCM(down);
      const b64 = base64FromInt16(pcm16);

      ws.send(JSON.stringify({ type: "audio", data: b64 }));
    };

    startBtn.disabled = true;
    stopBtn.disabled = false;

    log("ðŸŽ™ï¸ Listening...");
  }

  function stopVoice() {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: "stop" }));
      ws.close();
    }

    if (processor) processor.disconnect();
    if (audioCtx) audioCtx.close();
    if (micStream) micStream.getTracks().forEach(t => t.stop());

    startBtn.disabled = false;
    stopBtn.disabled = true;

    log("ðŸ›‘ Stopped");
  }

  // Model output PCM is 24kHz; resample to the AudioContext rate.
  function playAudioChunk(base64Pcm24k) {
    const int16 = int16FromBase64(base64Pcm24k);

    const float32 = new Float32Array(int16.length);
    for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 0x8000;

    const inputRate = 24000;
    const outRate = playCtx.sampleRate;
    const ratio = outRate / inputRate;

    const outLen = Math.round(float32.length * ratio);
    const resampled = new Float32Array(outLen);

    for (let i = 0; i < outLen; i++) {
      const src = i / ratio;
      const i0 = Math.floor(src);
      const i1 = Math.min(i0 + 1, float32.length - 1);
      const t = src - i0;
      resampled[i] = float32[i0] * (1 - t) + float32[i1] * t;
    }

    const buf = playCtx.createBuffer(1, resampled.length, outRate);
    buf.copyToChannel(resampled, 0);

    const node = playCtx.createBufferSource();
    node.buffer = buf;
    node.connect(playCtx.destination);

    const now = playCtx.currentTime;
    if (playQueueTime < now) playQueueTime = now;
    node.start(playQueueTime);
    playQueueTime += buf.duration;
  }

  startBtn.onclick = startVoice;
  stopBtn.onclick = stopVoice;
</script>
</body>
</html>
